import threading
import OpenSSL
import hashlib
import time
import os
import sys
import base64
import glob

class CertUtil(object):
	"""CertUtil module, based on mitmproxy"""

	# ca_vendor = 'GoAgent'
	ca_vendor = 'Railgun'
	ca_keyfile = 'CA.crt'
	ca_certdir = 'certs'
	ca_lock = threading.Lock()

	@staticmethod
	def create_ca():
		key = OpenSSL.crypto.PKey()
		key.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)
		ca = OpenSSL.crypto.X509()
		ca.set_serial_number(0)
		ca.set_version(2)
		subj = ca.get_subject()
		subj.countryName = 'CN'
		subj.stateOrProvinceName = 'Internet'
		subj.localityName = 'Cernet'
		subj.organizationName = CertUtil.ca_vendor
		subj.organizationalUnitName = '%s Root' % CertUtil.ca_vendor
		subj.commonName = '%s CA' % CertUtil.ca_vendor
		ca.gmtime_adj_notBefore(0)
		ca.gmtime_adj_notAfter(24 * 60 * 60 * 3652)
		ca.set_issuer(ca.get_subject())
		ca.set_pubkey(key)
		ca.add_extensions([
			OpenSSL.crypto.X509Extension(b'basicConstraints', True, b'CA:TRUE'),
			OpenSSL.crypto.X509Extension(b'nsCertType', True, b'sslCA'),
			OpenSSL.crypto.X509Extension(b'extendedKeyUsage', True, b'serverAuth,clientAuth,emailProtection,timeStamping,msCodeInd,msCodeCom,msCTLSign,msSGC,msEFS,nsSGC'),
			OpenSSL.crypto.X509Extension(b'keyUsage', False, b'keyCertSign, cRLSign'),
			OpenSSL.crypto.X509Extension(b'subjectKeyIdentifier', False, b'hash', subject=ca), ])
		ca.sign(key, 'sha512')
		return key, ca

	@staticmethod
	def dump_ca():
		key, ca = CertUtil.create_ca()
		with open(CertUtil.ca_keyfile, 'wb') as fp:
			fp.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca))
			fp.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key))

	@staticmethod
	def _get_cert(commonname, sans=()):
		with open(CertUtil.ca_keyfile, 'rb') as fp:
			content = fp.read()
			key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, content)
			ca = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, content)

		pkey = OpenSSL.crypto.PKey()
		pkey.generate_key(OpenSSL.crypto.TYPE_RSA, 2048)

		req = OpenSSL.crypto.X509Req()
		subj = req.get_subject()
		subj.countryName = 'CN'
		subj.stateOrProvinceName = 'Internet'
		subj.localityName = 'Cernet'
		subj.organizationalUnitName = '%s Branch' % CertUtil.ca_vendor
		if commonname[0] == '.':
			subj.commonName = '*' + commonname
			subj.organizationName = '*' + commonname
			sans = ['*'+commonname] + [x for x in sans if x != '*'+commonname]
		else:
			subj.commonName = commonname
			subj.organizationName = commonname
			sans = [commonname] + [x for x in sans if x != commonname]
		#req.add_extensions([OpenSSL.crypto.X509Extension(b'subjectAltName', True, ', '.join('DNS: %s' % x for x in sans)).encode()])
		req.set_pubkey(pkey)
		req.sign(pkey, 'sha512')

		cert = OpenSSL.crypto.X509()
		cert.set_version(2)
		try:
			cert.set_serial_number(int(hashlib.md5(commonname.encode('utf-8')).hexdigest(), 16))
		except OpenSSL.SSL.Error:
			cert.set_serial_number(int(time.time()*1000))
		cert.gmtime_adj_notBefore(0)
		cert.gmtime_adj_notAfter(60 * 60 * 24 * 3652)
		cert.set_issuer(ca.get_subject())
		cert.set_subject(req.get_subject())
		cert.set_pubkey(req.get_pubkey())
		if commonname[0] == '.':
			sans = ['*'+commonname] + [s for s in sans if s != '*'+commonname]
		else:
			sans = [commonname] + [s for s in sans if s != commonname]
		#cert.add_extensions([OpenSSL.crypto.X509Extension(b'subjectAltName', True, ', '.join('DNS: %s' % x for x in sans))])
		cert.sign(key, 'sha512')

		certfile = os.path.join(CertUtil.ca_certdir, commonname + '.crt')
		with open(certfile, 'wb') as fp:
			fp.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))
			fp.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, pkey))
		return certfile

	@staticmethod
	def get_cert(commonname, sans=()):
		if commonname.count('.') >= 2 and len(commonname.split('.')[-2]) > 4:
			commonname = '.'+commonname.partition('.')[-1]
		certfile = os.path.join(CertUtil.ca_certdir, commonname + '.crt')
		if os.path.exists(certfile):
			return certfile
		elif OpenSSL is None:
			return CertUtil.ca_keyfile
		else:
			with CertUtil.ca_lock:
				if os.path.exists(certfile):
					return certfile
				return CertUtil._get_cert(commonname, sans)

	@staticmethod
	def import_ca(certfile):
		commonname = os.path.splitext(os.path.basename(certfile))[0]
		if OpenSSL:
			try:
				with open(certfile, 'rb') as fp:
					x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fp.read())
					commonname = next(v.decode() for k, v in x509.get_subject().get_components() if k == b'O')
			except Exception as e:
				# logging.error('load_certificate(certfile=%r) failed:%s', certfile, e)
				print(e)
		if sys.platform.startswith('win'):
			import ctypes
			with open(certfile, 'rb') as fp:
				certdata = fp.read()
				if certdata.startswith(b'-----'):
					begin = b'-----BEGIN CERTIFICATE-----'
					end = b'-----END CERTIFICATE-----'
					certdata = base64.b64decode(b''.join(certdata[certdata.find(begin)+len(begin):certdata.find(end)].strip().splitlines()))
				crypt32 = ctypes.WinDLL(b'crypt32.dll'.decode())
				store_handle = crypt32.CertOpenStore(10, 0, 0, 0x4000 | 0x20000, b'ROOT'.decode())
				if not store_handle:
					return -1
				ret = crypt32.CertAddEncodedCertificateToStore(store_handle, 0x1, certdata, len(certdata), 4, None)
				crypt32.CertCloseStore(store_handle, 0)
				del crypt32
				return 0 if ret else -1
		elif sys.platform == 'darwin':
			return os.system(('security find-certificate -a -c "%s" | grep "%s" >/dev/null || security add-trusted-cert -d -r trustRoot -k "/Library/Keychains/System.keychain" "%s"' % (commonname, commonname, certfile.decode('utf-8'))).encode('utf-8'))
		elif sys.platform.startswith('linux'):
			import platform
			platform_distname = platform.dist()[0]
			if platform_distname == 'Ubuntu':
				pemfile = "/etc/ssl/certs/%s.pem" % commonname
				new_certfile = "/usr/local/share/ca-certificates/%s.crt" % commonname
				if not os.path.exists(pemfile):
					return os.system('cp "%s" "%s" && update-ca-certificates' % (certfile, new_certfile))
			elif any(os.path.isfile('%s/certutil' % x) for x in os.environ['PATH'].split(os.pathsep)):
				return os.system('certutil -L -d sql:$HOME/.pki/nssdb | grep "%s" || certutil -d sql:$HOME/.pki/nssdb -A -t "C,," -n "%s" -i "%s"' % (commonname, commonname, certfile))
			else:
				logging.warning('please install *libnss3-tools* package to import GoAgent root ca')
		return 0

	@staticmethod
	def check_ca():
		#Check CA exists
		capath = os.path.join(os.path.dirname(os.path.abspath(__file__)), CertUtil.ca_keyfile)
		certdir = os.path.join(os.path.dirname(__file__), CertUtil.ca_certdir)
		if not os.path.exists(capath):
			if not OpenSSL:
				# logging.critical('CA.key is not exist and OpenSSL is disabled, ABORT!')
				print('CA.key is not exist and OpenSSL is disabled, ABORT!')
				sys.exit(-1)
			if os.path.exists(certdir):
				if os.path.isdir(certdir):
					any(os.remove(x) for x in glob.glob(certdir+'/*.crt')+glob.glob(certdir+'/.*.crt'))
				else:
					os.remove(certdir)
					os.mkdir(certdir)
			CertUtil.dump_ca()
		if glob.glob('%s/*.key' % CertUtil.ca_certdir):
			for filename in glob.glob('%s/*.key' % CertUtil.ca_certdir):
				try:
					os.remove(filename)
					os.remove(os.path.splitext(filename)[0]+'.crt')
				except EnvironmentError:
					pass
		#Check CA imported
		if CertUtil.import_ca(capath) != 0:
			print('install root certificate failed, Please run as administrator/root/sudo')
		#Check Certs Dir
		if not os.path.exists(certdir):
			os.makedirs(certdir)
